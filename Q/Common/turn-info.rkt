#lang racket

(require racket/generic)
(require math/base)

(require struct-plus-plus)
(require threading)

(require Q/Common/map)
(require Q/Common/player)
(require Q/Common/data/event)
(require Q/Common/data/turn-action)
(require Q/Common/data/posn)
(require Q/Common/data/tile)
(require Q/Common/interfaces/serializable)
(require Q/Common/util/list)
(require Q/Common/util/misc)
(require Q/Common/config)

(provide
 turn-info++
 (struct-out turn-info)
 (contract-out
  [score-turn
   (-> turn-info? turn-action? natural?)]))


#; {type TurnInfo = (turn-info PlayerState
                               [Listof [Pairof PlayerId Natural]]
                               History
                               Board)}
;; A TurnInfo represents all the data necessary for a player to take their turn, including their
;; private knowledge, along with the public knowledge of turn order, scores, history, and the board.
;; INVARIANT: `scores` contains about every other player, and is ordered in the order of turns.
(struct++ turn-info
          ([state      player-state?]
           [scores     (listof (cons/c player-id? natural?))]
           [history    history?]
           [board      board?]
           [tiles-left natural?])
          #:transparent
          #:methods gen:serializable
          [(define/generic ->jsexpr* ->jsexpr)
           (define (->jsexpr ti)
             (match-define [turn-info state scores _history board tiles-left] ti)
             (hash 'map     (->jsexpr* board)
                   'tile*   tiles-left
                   'players (cons (->jsexpr* state)
                                  (rest scores))))])
#; {TurnInfo TurnAction -> Natural}
;; Score the given action for the given turn.
(define (score-turn info action)
  (match action
    [(place pments) (score/placement info pments)]
    [_              0]))


#; {TurnInfo [Listof TilePlacement] -> Natural}
;; Score the given placements for this turn
(define (score/placement info pments)
  (match-define [turn-info _ _ _ board _] info)
  (define base-points   (length pments))
  (define seq-points    (score/sequences board pments))
  (define qs-points     (score/qs board pments 6))
  (define placed-all    (if (= (length pments) (*hand-size*))
                            6
                            0))

  (+ base-points seq-points qs-points placed-all))

#; {Sequence -> Boolean}
;; Is the given sequence a Q?
(define (q-sequence? seq)
  (define tiles  (map placement-tile seq))
  (define colors (map tile-color tiles))
  (define shapes (map tile-shape tiles))
  (or (same-elements? colors tile-colors)
      (same-elements? shapes tile-shapes)))


#; {Board [Listof TilePlacement] -> [Listof [Listof TilePlacement]]}
;; Produce a list of sequences for each posn along every axis.
(define (get-sequences b placements)
  (define posns (map placement-posn placements))
  (define seqs
    (for*/set ([p posns] [axis axes])
      (collect-sequence b p axis)))
  (set->list seqs))

#; {Board [Listof TilePlacement] -> Natural}
;; Score the placements for the 2nd scoring rule: points added for extending
;; existing sequences
(define (score/sequences b pments)
  (~>> (get-sequences b pments)
       (filter-not (compose one? length))
       (map length)
       sum))

#; {Board [Listof TilePlacement] Natural -> Natural}
;; Score the Qs generated by the placements on the board
(define (score/qs b pments points-per-q)
  (~>> (get-sequences b pments)
       (filter q-sequence?)
       length
       (* points-per-q)))

#; {JPub -> TurnInfo}
(define (hash->turn-info++ jpub)
  (define jmap (hash-ref jpub 'map))
  (define tile* (hash-ref jpub 'tile*))
  (define players (hash-ref jpub 'players))
  (define jplayer (first players))
  (define scores* (rest players))
  
  (define state (hash->player-state++ jplayer))
  (define board (hash->board++ jmap))
  (define scores
    (for/list ([score scores*] [i (in-naturals)])
      (cons (string->symbol (number->string i)) score)))
  
  (turn-info state scores '() board tile*))
