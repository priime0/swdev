#lang racket

(require (rename-in (only-in lazy define)
                    [define define/lazy]))

(require racket/generic)
(require math/base)

(require struct-plus-plus)
(require threading)

(require Q/Common/map)
(require Q/Common/player-state)
(require Q/Common/data/event)
(require Q/Common/data/turn-action)
(require Q/Common/data/posn)
(require Q/Common/data/tile)
(require Q/Common/interfaces/serializable)
(require Q/Common/util/list)
(require Q/Common/util/misc)
(require Q/Common/config)

(provide
 turn-info++
 (struct-out turn-info)
 hash->turn-info++
 (contract-out
  [score-turn
   (-> turn-info? turn-action? natural?)]
  [valid-action?
   (-> turn-info? turn-action? boolean?)]))


#; {type TurnInfo = (turn-info PlayerState
                               [Listof [Pairof PlayerId Natural]]
                               History
                               Board)}
;; A TurnInfo represents all the data necessary for a player to take their turn, including their
;; private knowledge, along with the public knowledge of turn order, scores, history, and the board.
;; INVARIANT: `scores` contains about every other player, and is ordered in the order of turns.
(struct++ turn-info
          ([state      player-state?]
           [scores     (listof (cons/c player-id? natural?))]
           [history    history?]
           [board      board?]
           [tiles-left natural?])
          #:transparent
          #:methods gen:serializable
          [(define/generic ->jsexpr* ->jsexpr)
           (define (->jsexpr ti)
             (match-define [turn-info state scores _history board tiles-left] ti)
             (hash 'map     (->jsexpr* board)
                   'tile*   tiles-left
                   'players (cons (->jsexpr* state)
                                  (rest scores))))])

#; {TurnInfo TurnAction -> Boolean}
;; Is the given action on this turn valid?
(define (valid-action? info action)
  (match action
    [(place pments) (valid-place? info pments)]
    [(exchange)     (valid-exchange? info)]
    [(pass)         #t]))

#; {TurnInfo [Listof TilePlacement] -> Boolean}
;; Is the proposed placement for the given turn valid?
(define (valid-place? info placements)
  (match-define [turn-info [player-state _ _ hand] _ _ board _] info)

  (define/lazy aligned?
    (same-axis? (map placement-posn placements)))
  (define/lazy in-hand?
    (contains-all? hand (map placement-tile placements)))

  (and (pair? placements)
       aligned?
       (legal-placements? info placements)
       in-hand?))

#; {TurnInfo [Listof TilePlacement] -> Boolean}
;; Is the given sequence of placements a valid 
(define (legal-placements? info placements)
  (define board (turn-info-board info))
  (for/fold ([b^ board]
             #:result (not (false? b^)))
            ([pment placements]
             #:break (not b^))
    (and (valid-placement? b^ pment)
         (add-tile b^ pment))))


#; {TurnInfo -> Boolean}
;; Is an exchange a valid move for this turn?
(define (valid-exchange? info)
  (>= (turn-info-tiles-left info) (*hand-size*)))


#; {TurnInfo TurnAction -> Natural}
;; Score the given action for the given turn.
(define (score-turn info action)
  (match action
    [(place pments) (score/placement info pments)]
    [_              0]))


#; {TurnInfo [Listof TilePlacement] -> Natural}
;; Score the given placements for this turn
(define (score/placement info pments)
  (match-define [turn-info _ _ _ board _] info)
  (define base-points   (length pments))
  (define seq-points    (score/sequences board pments))
  (define qs-points     (score/qs board pments))
  (define placed-all    (if (= (length pments) (*hand-size*))
                            (*hand-size*)
                            0))

  (+ base-points seq-points qs-points placed-all))

#; {Sequence -> Boolean}
;; Is the given sequence a Q?
(define (q-sequence? seq)
  (define tiles  (map placement-tile seq))
  (define colors (map tile-color tiles))
  (define shapes (map tile-shape tiles))
  (or (same-elements? colors tile-colors)
      (same-elements? shapes tile-shapes)))


#; {Board [Listof TilePlacement] -> [Listof [Listof TilePlacement]]}
;; Produce a list of sequences for each posn along every axis.
(define (get-sequences b placements)
  (define posns (map placement-posn placements))
  (define seqs
    (for*/set ([p posns] [axis axes])
      (collect-sequence b p axis)))
  (set->list seqs))

#; {Board [Listof TilePlacement] -> Natural}
;; Score the placements for the 2nd scoring rule: points added for extending
;; existing sequences
(define (score/sequences b pments)
  (~>> (get-sequences b pments)
       (filter-not (compose one? length))
       (map length)
       sum))

#; {Board [Listof TilePlacement] Natural -> Natural}
;; Score the Qs generated by the placements on the board
(define (score/qs b pments)
  (define points-per-q 6)
  (~>> (get-sequences b pments)
       (filter q-sequence?)
       length
       (* points-per-q)))

#; {JPub -> TurnInfo}
(define (hash->turn-info++ jpub)
  (define jmap (hash-ref jpub 'map))
  (define tile* (hash-ref jpub 'tile*))
  (define players (hash-ref jpub 'players))
  (define jplayer (first players))
  (define scores* (rest players))
  
  (define state (hash->player-state++ jplayer))
  (define board (hash->board++ jmap))
  (define scores
    (for/list ([score scores*] [i (in-naturals)])
      (cons (string->symbol (number->string i)) score)))
  
  (turn-info state scores '() board tile*))


(module+ test
  (require rackunit)

  (define hand1  (list (tile 'red 'square)
                       (tile 'blue 'clover)
                       (tile 'blue 'square)
                       (tile 'green 'star)
                       (tile 'green '8star)
                       (tile 'orange 'diamond)))
  (define ps1 (player-state '|0| 0 hand1))
  (define b1  (~>> (make-board (tile 'red 'diamond))
                   (add-tile _ (placement (posn 0 1) (tile 'red 'circle)))
                   (add-tile _ (placement (posn 1 1) (tile 'blue 'circle)))))

  ;;;; Example turn infos
  (define ti1 (turn-info ps1 '() '() b1 10))
  (define ti2 (turn-info ps1 '() '() b1 5))
  (define ti3 (turn-info ps1 '() '() b1 6))

  (define all-placement (list (placement (posn 0 2) (tile 'red 'square))
                              (placement (posn 0 3) (tile 'blue 'clover))
                              (placement (posn 0 4) (tile 'blue 'square))
                              (placement (posn 0 5) (tile 'green 'star))
                              (placement (posn 0 6) (tile 'green '8star))
                              (placement (posn 0 7) (tile 'orange 'diamond))))
  (define ti+ (set-turn-info-board ti1 (add-tiles b1 all-placement)))

  ;;;; Example turn actions
  (define passa (pass))
  (define excha (exchange))
  ;; invalid empty placement
  (define empl '())
  ;; valid placement
  (define vpl (list (placement (posn 0 2) (tile 'red 'square))
                    (placement (posn 1 2) (tile 'blue 'square))))
  ;; placement with tile not in hand
  (define not-hand (list (placement (posn 0 2) (tile 'red 'square))
                         (placement (posn 1 2) (tile 'blue 'circle))))
  ;; placement with tiles not in same axis
  (define bad-axis (list (placement (posn 0 2) (tile 'red 'square))
                         (placement (posn 2 0) (tile 'blue 'clover))))
  ;; illegal placement by matching rules
  (define illpl (list (placement (posn 0 2) (tile 'red 'square))
                      (placement (posn 1 2) (tile 'blue 'clover))))

  ;; new turn info, after applying vpl
  (define ti1+ (set-turn-info-board ti1 (add-tiles b1 vpl)))

  ;; board with two unfinished q's
  (define b2 (~> (make-board (tile 'red 'diamond))
                 (add-tiles (list (placement (posn 0 1) (tile 'red 'circle))
                                  (placement (posn 0 2) (tile 'red 'clover))
                                  (placement (posn 0 3) (tile 'red 'star))
                                  (placement (posn 0 4) (tile 'red '8star))
                                  (placement (posn 1 0) (tile 'green 'diamond))
                                  (placement (posn 2 0) (tile 'blue 'diamond))
                                  (placement (posn 2 1) (tile 'blue '8star))
                                  (placement (posn 2 2) (tile 'blue '8star))
                                  (placement (posn 2 3) (tile 'blue 'square))
                                  (placement (posn 2 4) (tile 'blue 'circle))
                                  (placement (posn 2 -1) (tile 'blue 'star))))))
  (define ti4 (turn-info ps1 '() '() b2 10))
  (define q-placements (list (placement (posn 0 5) (tile 'red 'square))
                             (placement (posn 1 5) (tile 'blue 'square))
                             (placement (posn 2 5) (tile 'blue 'clover))))
  (define b2+ (add-tiles b2 q-placements))
  (define ti4+ (set-turn-info-board ti4 b2+)))

(module+ test

  (test-false
   "exchange when ref has < 6 tiles"
   (valid-exchange? ti2))

  (test-true
   "exchange when ref has = 6 tiles"
   (valid-exchange? ti3))

  (test-true
   "exchange when ref has > 6 tiles"
   (valid-exchange? ti1))

  (test-true
   "valid placement is legal"
   (legal-placements? ti1 vpl))

  (test-false
   "tile doesn't match placement rules, therefore is invalid"
   (legal-placements? ti1 illpl))

  (test-false
   "tile not in hand is invalid action"
   (valid-place? ti1 not-hand))

  (test-false
   "empty place is an invalid action"
   (valid-place? ti1 empl))

  (test-false
   "tiles not aligned on axis is an invalid action"
   (valid-place? ti1 bad-axis))

  (test-false
   "placement not matching neighbor-wise q matching is invalid"
   (valid-place? ti1 illpl))

  (test-true
   "non-empty matching placement along same axis in hand is valid"
   (valid-place? ti1 vpl))

  (test-true
   "valid placement is a valid action"
   (valid-action? ti1 (place vpl)))

  (test-true
   "pass is a valid action"
   (valid-action? ti1 passa))

  (test-true
   "exchange with >= 6 tiles is a valid action"
   (valid-action? ti1 excha))

  (test-false
   "exchange with < 6 tiles is an invalid action"
   (valid-action? ti2 excha))

  (test-false
   "empty placement is an invalid action"
   (valid-action? ti1 (place empl)))

  (test-false
   "placement with tiles not in hand is invalid"
   (valid-action? ti1 (place not-hand)))

  (test-false
   "placement with tiles that dont match neighbors is an invalid action"
   (valid-action? ti1 (place illpl)))

  (test-false
   "placement not aligned along 1 axis is invalid"
   (valid-action? ti1 (place bad-axis)))

  ;;;; SCORING TESTS

  (test-equal?
   "test scoring for a valid placement"
   (score-turn ti1+ (place vpl))
   9)

  (test-equal?
   "exchange is worth 0 points"
   (score-turn ti1 excha)
   0)

  (test-equal?
   "pass is worth 0 points"
   (score-turn ti1 passa)
   0)

  (test-false
   "sequence on first row of b2 is not a q"
   (q-sequence? (collect-sequence b2 (posn 0 0) horizontal-axis)))

  (test-true
   "sequence on first row of b2+ is a q"
   (q-sequence? (collect-sequence b2+ (posn 0 0) horizontal-axis)))

  (test-false
   "sequence on first row of b2 is a not q"
   (q-sequence? (collect-sequence b2 (posn 2 0) horizontal-axis)))

  (test-false
   "sequence on first row of b2+ is a not q"
   (q-sequence? (collect-sequence b2+ (posn 2 0) horizontal-axis)))

  (test-check
   "get sequences returns correct sequences for placements"
   set=?
   (get-sequences b2+ q-placements)
   (list (collect-sequence b2+ (posn 0 5) horizontal-axis)
         (collect-sequence b2+ (posn 0 5) vertical-axis)
         (collect-sequence b2+ (posn 1 5) horizontal-axis)
         (collect-sequence b2+ (posn 1 5) vertical-axis)
         (collect-sequence b2+ (posn 2 5) horizontal-axis)
         (collect-sequence b2+ (posn 2 5) vertical-axis)))

  (test-equal?
   "score qs for a placement with one q"
   (score/qs b2+ q-placements)
   6)

  (test-equal?
   "score qs for a placement with one q" 
  (score/sequences b2+ q-placements)
   16)

  (test-equal?
   "score placement"
   (score/placement ti4+ q-placements)
   25)

  (test-equal?
   "score entire hand placement"
   (score/placement ti+ all-placement)
   20)

  (test-equal?
   "score turn action of q placement"
   (score-turn ti4+ (place q-placements))
   25)

  (test-equal?
   "score turn action of entire hand placement"
   (score-turn ti+ (place all-placement))
   20))
