#lang racket

(require (rename-in (only-in lazy define)
                    [define define/lazy]))

(require racket/generic)
(require math/base)

(require struct-plus-plus)
(require threading)

(require Q/Common/map)
(require Q/Common/player)
(require Q/Common/data/event)
(require Q/Common/data/turn-action)
(require Q/Common/data/posn)
(require Q/Common/data/tile)
(require Q/Common/interfaces/serializable)
(require Q/Common/util/list)
(require Q/Common/util/misc)
(require Q/Common/config)

(provide
 turn-info++
 (struct-out turn-info)
 (contract-out
  [score-turn
   (-> turn-info? turn-action? natural?)]
  [valid-action?
   (-> turn-info? turn-action? boolean?)]))


#; {type TurnInfo = (turn-info PlayerState
                               [Listof [Pairof PlayerId Natural]]
                               History
                               Board)}
;; A TurnInfo represents all the data necessary for a player to take their turn, including their
;; private knowledge, along with the public knowledge of turn order, scores, history, and the board.
;; INVARIANT: `scores` contains about every other player, and is ordered in the order of turns.
(struct++ turn-info
          ([state      player-state?]
           [scores     (listof (cons/c player-id? natural?))]
           [history    history?]
           [board      board?]
           [tiles-left natural?])
          #:transparent
          #:methods gen:serializable
          [(define/generic ->jsexpr* ->jsexpr)
           (define (->jsexpr ti)
             (match-define [turn-info state scores _history board tiles-left] ti)
             (hash 'map     (->jsexpr* board)
                   'tile*   tiles-left
                   'players (cons (->jsexpr* state)
                                  (rest scores))))])

#; {TurnInfo TurnAction -> Boolean}
;; Is the given action on this turn valid?
(define (valid-action? info action)
  (match action
    [(place pments) (valid-place? info pments)]
    [(exchange)     (valid-exchange? info)]
    [(pass)         #t]))

#; {TurnInfo [Listof TilePlacement] -> Boolean}
;; Is the proposed placement for the given turn valid?
(define (valid-place? info placements)
  (match-define [turn-info [player-state _ _ hand] _ _ board _] info)

  (define/lazy aligned?
    (same-axis? (map placement-posn placements)))
  (define/lazy in-hand?
    (contains-all? hand (map placement-tile placements)))

  (and (pair? placements)
       aligned?
       (legal-placements? info placements)
       in-hand?))

(define (legal-placements? info placements)
  (match-define [turn-info [player-state _ _ hand] _ _ board _] info)
  (for/fold ([b^ board]
             #:result b^)
            ([pment placements]
             #:break (not b^))
    (and (valid-placement? b^ pment)
         (add-tile b^ pment))))


#; {TurnInfo -> Boolean}
;; Is an exchange a valid move for this turn?
(define (valid-exchange? info)
  (>= (turn-info-tiles-left info) (*hand-size*)))


#; {TurnInfo TurnAction -> Natural}
;; Score the given action for the given turn.
(define (score-turn info action)
  (match action
    [(place pments) (score/placement info pments)]
    [_              0]))


#; {TurnInfo [Listof TilePlacement] -> Natural}
;; Score the given placements for this turn

;; Testing Task: have to ignore EOG bonus-could parameterize *hand-size* to be -1 so its never true, scuffed
(define (score/placement info pments)
  (match-define [turn-info _ _ _ board _] info)
  (define base-points   (length pments))
  (define seq-points    (score/sequences board pments))
  (define qs-points     (score/qs board pments))
  (define placed-all    (if (= (length pments) (*hand-size*))
                            (*hand-size*)
                            0))

  (+ base-points seq-points qs-points placed-all))

#; {Sequence -> Boolean}
;; Is the given sequence a Q?
(define (q-sequence? seq)
  (define tiles  (map placement-tile seq))
  (define colors (map tile-color tiles))
  (define shapes (map tile-shape tiles))
  (or (same-elements? colors tile-colors)
      (same-elements? shapes tile-shapes)))


#; {Board [Listof TilePlacement] -> [Listof [Listof TilePlacement]]}
;; Produce a list of sequences for each posn along every axis.
(define (get-sequences b placements)
  (define posns (map placement-posn placements))
  (define seqs
    (for*/set ([p posns] [axis axes])
      (collect-sequence b p axis)))
  (set->list seqs))

#; {Board [Listof TilePlacement] -> Natural}
;; Score the placements for the 2nd scoring rule: points added for extending
;; existing sequences
(define (score/sequences b pments)
  (~>> (get-sequences b pments)
       (filter-not (compose one? length))
       (map length)
       sum))

#; {Board [Listof TilePlacement] Natural -> Natural}
;; Score the Qs generated by the placements on the board
(define (score/qs b pments)
  (define points-per-q 6)
  (~>> (get-sequences b pments)
       (filter q-sequence?)
       length
       (* points-per-q)))

#; {JPub -> TurnInfo}
(define (hash->turn-info++ jpub)
  (define jmap (hash-ref jpub 'map))
  (define tile* (hash-ref jpub 'tile*))
  (define players (hash-ref jpub 'players))
  (define jplayer (first players))
  (define scores* (rest players))
  
  (define state (hash->player-state++ jplayer))
  (define board (hash->board++ jmap))
  (define scores
    (for/list ([score scores*] [i (in-naturals)])
      (cons (string->symbol (number->string i)) score)))
  
  (turn-info state scores '() board tile*))
